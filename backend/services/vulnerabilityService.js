/**
 * Vulnerability Scoring Service
 * 
 * Centralized service for vulnerability calculations and priority management
 */

const Beneficiary = require('../models/Beneficiary');

class VulnerabilityService {
  
  /**
   * Calculate score for a single beneficiary
   * @param {Object} beneficiary - Beneficiary document
   * @returns {Object} Score and breakdown
   */
  static calculateScore(beneficiary) {
    return beneficiary.calculateVulnerabilityScore();
  }
  
  /**
   * Update score for a single beneficiary
   * @param {String} beneficiaryId - Beneficiary ID
   * @returns {Object} Update result
   */
  static async updateBeneficiaryScore(beneficiaryId) {
    try {
      const beneficiary = await Beneficiary.findById(beneficiaryId);
      
      if (!beneficiary) {
        throw new Error('Beneficiary not found');
      }
      
      if (beneficiary.status !== 'active') {
        return {
          success: false,
          message: 'Beneficiary is not active'
        };
      }
      
      const result = await beneficiary.updateVulnerabilityScore();
      
      return {
        success: true,
        ...result
      };
    } catch (err) {
      console.error('[VulnerabilityService] Update error:', err);
      throw err;
    }
  }
  
  /**
   * Bulk update scores for all active beneficiaries
   * @returns {Object} Summary of updates
   */
  static async updateAllScores() {
    try {
      console.log('[VulnerabilityService] Starting bulk score update...');
      const startTime = Date.now();
      
      const results = await Beneficiary.updateAllVulnerabilityScores();
      
      const duration = ((Date.now() - startTime) / 1000).toFixed(2);
      
      console.log(`[VulnerabilityService] Bulk update complete in ${duration}s`);
      console.log(`  - Updated: ${results.updated}`);
      console.log(`  - Escalated: ${results.escalated.length}`);
      console.log(`  - Errors: ${results.errors.length}`);
      
      // Log escalations
      if (results.escalated.length > 0) {
        console.log('\n[ALERT] Priority Escalations:');
        results.escalated.forEach(esc => {
          console.log(`  ðŸš¨ ${esc.name} (ID: ${esc.id})`);
          console.log(`     ${esc.from} â†’ ${esc.to} (Score: ${esc.score})`);
        });
      }
      
      return {
        success: true,
        duration,
        ...results
      };
    } catch (err) {
      console.error('[VulnerabilityService] Bulk update failed:', err);
      throw err;
    }
  }
  
  /**
   * Get priority distribution statistics
   * @returns {Object} Priority counts and stats
   */
  static async getPriorityDistribution() {
    try {
      const stats = await Beneficiary.getPriorityStats();
      
      // Format results
      const distribution = {
        CRITICAL: { count: 0, avgScore: 0 },
        HIGH: { count: 0, avgScore: 0 },
        MEDIUM: { count: 0, avgScore: 0 },
        LOW: { count: 0, avgScore: 0 }
      };
      
      stats.forEach(stat => {
        if (stat._id && distribution[stat._id]) {
          distribution[stat._id] = {
            count: stat.count,
            avgScore: Math.round(stat.avgScore)
          };
        }
      });
      
      const total = Object.values(distribution).reduce((sum, d) => sum + d.count, 0);
      
      return {
        distribution,
        total
      };
    } catch (err) {
      console.error('[VulnerabilityService] Get distribution error:', err);
      throw err;
    }
  }
  
  /**
   * Get beneficiaries by priority level
   * @param {String} priorityLevel - CRITICAL, HIGH, MEDIUM, LOW
   * @param {Number} limit - Max results
   * @returns {Array} Beneficiaries
   */
  static async getByPriority(priorityLevel, limit = 100) {
    try {
      return await Beneficiary.find({
        status: 'active',
        priorityLevel
      })
      .sort({ vulnerabilityScore: -1, estimatedDelivery: 1 })
      .limit(limit)
      .populate('registeredBy', 'name email')
      .select('-biometric.faceEmbedding'); // Exclude large embedding data
    } catch (err) {
      console.error('[VulnerabilityService] Get by priority error:', err);
      throw err;
    }
  }
  
  /**
   * Get urgent cases (CRITICAL + overdue HIGH)
   * @returns {Array} Urgent beneficiaries
   */
  static async getUrgentCases() {
    try {
      const now = new Date();
      
      return await Beneficiary.find({
        status: 'active',
        $or: [
          { priorityLevel: 'CRITICAL' },
          {
            priorityLevel: 'HIGH',
            estimatedDelivery: { $lt: now }
          }
        ]
      })
      .sort({ vulnerabilityScore: -1 })
      .limit(50)
      .populate('registeredBy', 'name email');
    } catch (err) {
      console.error('[VulnerabilityService] Get urgent cases error:', err);
      throw err;
    }
  }
  
  /**
   * Check and alert for escalations
   * Called after bulk updates
   * @param {Array} escalations - List of escalated cases
   */
  static async sendEscalationAlerts(escalations) {
    if (escalations.length === 0) return;
    
    console.log('\n========== ESCALATION ALERTS ==========');
    
    for (const esc of escalations) {
      const message = `
ðŸš¨ PRIORITY ESCALATION ALERT
Beneficiary: ${esc.name}
ID: ${esc.id}
Priority Change: ${esc.from} â†’ ${esc.to}
Vulnerability Score: ${esc.score}/100

Action Required: Schedule delivery immediately.
      `;
      
      console.log(message);
      
      // TODO: Send SMS/Email notifications
      // await smsService.sendAlert(esc.phone, message);
      // await emailService.sendAlert(esc.email, message);
    }
    
    console.log('=======================================\n');
  }
}

module.exports = VulnerabilityService;